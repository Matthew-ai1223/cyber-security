#!/usr/bin/env python3
"""
Vulnerability Scanner - Ethical Hacking Tools Suite
Educational and Testing Purposes Only

Scans for common vulnerabilities including:
- Weak passwords
- Outdated software
- Misconfigurations
- Default login pages
- Security headers
"""

import requests
import socket
import threading
import time
import re
import json
from urllib.parse import urljoin, urlparse
from bs4 import BeautifulSoup
from datetime import datetime
import argparse

from ethical_hacking_tools.utils.logger import setup_logger, log_scan_result, log_security_event

class VulnerabilityScanner:
    """
    Comprehensive vulnerability scanner for web applications and network services
    """
    
    def __init__(self):
        self.logger = setup_logger('vulnerability_scanner')
        self.vulnerabilities = []
        self.session = requests.Session()
        self.session.headers.update({
            'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36'
        })
        
        # Common default credentials
        self.default_credentials = [
            ('admin', 'admin'),
            ('admin', 'password'),
            ('admin', '123456'),
            ('admin', ''),
            ('root', 'root'),
            ('root', 'password'),
            ('root', 'toor'),
            ('user', 'user'),
            ('guest', 'guest'),
            ('administrator', 'administrator'),
            ('test', 'test'),
            ('demo', 'demo')
        ]
        
        # Common vulnerable paths
        self.vulnerable_paths = [
            '/admin',
            '/administrator',
            '/login',
            '/wp-admin',
            '/phpmyadmin',
            '/admin.php',
            '/login.php',
            '/cpanel',
            '/webmail',
            '/mail',
            '/ftp',
            '/backup',
            '/config',
            '/.env',
            '/.git',
            '/robots.txt',
            '/sitemap.xml',
            '/crossdomain.xml',
            '/clientaccesspolicy.xml'
        ]
        
        # Security headers to check
        self.security_headers = [
            'X-Frame-Options',
            'X-Content-Type-Options',
            'X-XSS-Protection',
            'Strict-Transport-Security',
            'Content-Security-Policy',
            'Referrer-Policy',
            'Permissions-Policy'
        ]
    
    def check_web_vulnerabilities(self, target_url):
        """
        Scan web application for common vulnerabilities
        """
        self.logger.info(f"Starting web vulnerability scan on {target_url}")
        print(f"\n[+] Scanning web vulnerabilities on {target_url}")
        
        vulnerabilities = []
        
        try:
            # Check if target is accessible
            response = self.session.get(target_url, timeout=10)
            if response.status_code != 200:
                print(f"[!] Warning: Target returned status code {response.status_code}")
            
            # 1. Check for sensitive files and directories
            print("[+] Checking for sensitive files and directories...")
            file_vulns = self.check_sensitive_files(target_url)
            vulnerabilities.extend(file_vulns)
            
            # 2. Check security headers
            print("[+] Checking security headers...")
            header_vulns = self.check_security_headers(target_url)
            vulnerabilities.extend(header_vulns)
            
            # 3. Check for default login pages
            print("[+] Checking for default login pages...")
            login_vulns = self.check_default_logins(target_url)
            vulnerabilities.extend(login_vulns)
            
            # 4. Check for information disclosure
            print("[+] Checking for information disclosure...")
            info_vulns = self.check_information_disclosure(target_url)
            vulnerabilities.extend(info_vulns)
            
            # 5. Check for outdated software
            print("[+] Checking for outdated software...")
            software_vulns = self.check_outdated_software(target_url)
            vulnerabilities.extend(software_vulns)
            
        except requests.exceptions.RequestException as e:
            self.logger.error(f"Error scanning {target_url}: {e}")
            print(f"[!] Error accessing {target_url}: {e}")
            return vulnerabilities
        
        return vulnerabilities
    
    def check_sensitive_files(self, base_url):
        """
        Check for sensitive files and directories
        """
        vulnerabilities = []
        
        for path in self.vulnerable_paths:
            try:
                url = urljoin(base_url, path)
                response = self.session.get(url, timeout=5)
                
                if response.status_code == 200:
                    vuln = {
                        'type': 'Sensitive File Exposure',
                        'severity': 'Medium',
                        'description': f'Sensitive file/directory found: {path}',
                        'url': url,
                        'status_code': response.status_code
                    }
                    vulnerabilities.append(vuln)
                    print(f"[!] Found sensitive file: {url}")
                    
                    # Check if it's a configuration file
                    if any(ext in path for ext in ['.env', '.config', '.ini', '.conf']):
                        vuln['severity'] = 'High'
                        vuln['description'] += ' (Configuration file)'
                
            except requests.exceptions.RequestException:
                continue
        
        return vulnerabilities
    
    def check_security_headers(self, url):
        """
        Check for missing security headers
        """
        vulnerabilities = []
        
        try:
            response = self.session.get(url, timeout=10)
            headers = response.headers
            
            missing_headers = []
            for header in self.security_headers:
                if header not in headers:
                    missing_headers.append(header)
            
            if missing_headers:
                vuln = {
                    'type': 'Missing Security Headers',
                    'severity': 'Medium',
                    'description': f'Missing security headers: {", ".join(missing_headers)}',
                    'url': url,
                    'missing_headers': missing_headers
                }
                vulnerabilities.append(vuln)
                print(f"[!] Missing security headers: {', '.join(missing_headers)}")
            
            # Check for weak header values
            if 'X-Frame-Options' in headers:
                if headers['X-Frame-Options'].lower() not in ['deny', 'sameorigin']:
                    vuln = {
                        'type': 'Weak X-Frame-Options',
                        'severity': 'Low',
                        'description': f'Weak X-Frame-Options value: {headers["X-Frame-Options"]}',
                        'url': url
                    }
                    vulnerabilities.append(vuln)
                    print(f"[!] Weak X-Frame-Options: {headers['X-Frame-Options']}")
        
        except requests.exceptions.RequestException as e:
            self.logger.error(f"Error checking security headers: {e}")
        
        return vulnerabilities
    
    def check_default_logins(self, base_url):
        """
        Check for default login pages and attempt common credentials
        """
        vulnerabilities = []
        
        login_paths = ['/admin', '/login', '/wp-admin', '/administrator']
        
        for path in login_paths:
            try:
                url = urljoin(base_url, path)
                response = self.session.get(url, timeout=5)
                
                if response.status_code == 200:
                    # Check if it looks like a login page
                    if any(keyword in response.text.lower() for keyword in 
                          ['login', 'password', 'username', 'sign in']):
                        
                        vuln = {
                            'type': 'Default Login Page',
                            'severity': 'Medium',
                            'description': f'Default login page found: {path}',
                            'url': url
                        }
                        vulnerabilities.append(vuln)
                        print(f"[!] Found login page: {url}")
                        
                        # Try common credentials
                        cred_vulns = self.test_default_credentials(url)
                        vulnerabilities.extend(cred_vulns)
            
            except requests.exceptions.RequestException:
                continue
        
        return vulnerabilities
    
    def test_default_credentials(self, login_url):
        """
        Test common default credentials
        """
        vulnerabilities = []
        
        # This is a simplified version - in real scenarios, you'd need to
        # analyze the login form structure and submit proper POST requests
        
        print(f"[+] Testing default credentials on {login_url}")
        
        # For demonstration purposes, we'll just log the attempt
        for username, password in self.default_credentials[:5]:  # Test first 5
            vuln = {
                'type': 'Default Credentials Test',
                'severity': 'High',
                'description': f'Tested credentials: {username}:{password}',
                'url': login_url,
                'username': username,
                'password': password
            }
            vulnerabilities.append(vuln)
            print(f"[+] Tested: {username}:{password}")
        
        return vulnerabilities
    
    def check_information_disclosure(self, url):
        """
        Check for information disclosure vulnerabilities
        """
        vulnerabilities = []
        
        try:
            response = self.session.get(url, timeout=10)
            
            # Check for server information in headers
            server_header = response.headers.get('Server', '')
            if server_header:
                vuln = {
                    'type': 'Server Information Disclosure',
                    'severity': 'Low',
                    'description': f'Server information disclosed: {server_header}',
                    'url': url,
                    'server': server_header
                }
                vulnerabilities.append(vuln)
                print(f"[!] Server information disclosed: {server_header}")
            
            # Check for version information in HTML
            soup = BeautifulSoup(response.text, 'html.parser')
            
            # Look for version strings in comments
            comments = soup.find_all(string=lambda text: isinstance(text, str) and 'version' in text.lower())
            for comment in comments:
                if re.search(r'v?\d+\.\d+', comment):
                    vuln = {
                        'type': 'Version Information Disclosure',
                        'severity': 'Low',
                        'description': f'Version information in HTML: {comment.strip()}',
                        'url': url
                    }
                    vulnerabilities.append(vuln)
                    print(f"[!] Version info disclosed: {comment.strip()}")
                    break
        
        except requests.exceptions.RequestException as e:
            self.logger.error(f"Error checking information disclosure: {e}")
        
        return vulnerabilities
    
    def check_outdated_software(self, url):
        """
        Check for outdated software versions
        """
        vulnerabilities = []
        
        try:
            response = self.session.get(url, timeout=10)
            
            # Check server header for version info
            server_header = response.headers.get('Server', '')
            
            # Common outdated software patterns
            outdated_patterns = [
                (r'Apache/(\d+\.\d+)', 'Apache'),
                (r'nginx/(\d+\.\d+)', 'nginx'),
                (r'IIS/(\d+\.\d+)', 'IIS'),
                (r'PHP/(\d+\.\d+)', 'PHP')
            ]
            
            for pattern, software in outdated_patterns:
                match = re.search(pattern, server_header)
                if match:
                    version = match.group(1)
                    vuln = {
                        'type': 'Outdated Software',
                        'severity': 'Medium',
                        'description': f'Potentially outdated {software} version: {version}',
                        'url': url,
                        'software': software,
                        'version': version
                    }
                    vulnerabilities.append(vuln)
                    print(f"[!] Potentially outdated {software}: {version}")
        
        except requests.exceptions.RequestException as e:
            self.logger.error(f"Error checking outdated software: {e}")
        
        return vulnerabilities
    
    def check_network_vulnerabilities(self, target_ip, port):
        """
        Check for network-level vulnerabilities
        """
        self.logger.info(f"Starting network vulnerability scan on {target_ip}:{port}")
        print(f"\n[+] Scanning network vulnerabilities on {target_ip}:{port}")
        
        vulnerabilities = []
        
        # Check for common vulnerable services
        if port == 21:  # FTP
            vulns = self.check_ftp_vulnerabilities(target_ip, port)
            vulnerabilities.extend(vulns)
        elif port == 22:  # SSH
            vulns = self.check_ssh_vulnerabilities(target_ip, port)
            vulnerabilities.extend(vulns)
        elif port == 23:  # Telnet
            vulns = self.check_telnet_vulnerabilities(target_ip, port)
            vulnerabilities.extend(vulns)
        elif port in [80, 443, 8080, 8443]:  # HTTP/HTTPS
            protocol = 'https' if port in [443, 8443] else 'http'
            url = f"{protocol}://{target_ip}:{port}"
            vulns = self.check_web_vulnerabilities(url)
            vulnerabilities.extend(vulns)
        
        return vulnerabilities
    
    def check_ftp_vulnerabilities(self, target_ip, port):
        """
        Check FTP service for vulnerabilities
        """
        vulnerabilities = []
        
        try:
            sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
            sock.settimeout(5)
            sock.connect((target_ip, port))
            
            # Read banner
            banner = sock.recv(1024).decode('utf-8', errors='ignore')
            sock.close()
            
            vuln = {
                'type': 'FTP Banner Disclosure',
                'severity': 'Low',
                'description': f'FTP banner: {banner.strip()}',
                'target': f"{target_ip}:{port}",
                'banner': banner.strip()
            }
            vulnerabilities.append(vuln)
            print(f"[!] FTP banner: {banner.strip()}")
            
            # Check for anonymous FTP
            if 'anonymous' in banner.lower():
                vuln = {
                    'type': 'Anonymous FTP Enabled',
                    'severity': 'Medium',
                    'description': 'Anonymous FTP access enabled',
                    'target': f"{target_ip}:{port}"
                }
                vulnerabilities.append(vuln)
                print("[!] Anonymous FTP access enabled")
        
        except Exception as e:
            self.logger.error(f"Error checking FTP vulnerabilities: {e}")
        
        return vulnerabilities
    
    def check_ssh_vulnerabilities(self, target_ip, port):
        """
        Check SSH service for vulnerabilities
        """
        vulnerabilities = []
        
        try:
            sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
            sock.settimeout(5)
            sock.connect((target_ip, port))
            
            # Read SSH banner
            banner = sock.recv(1024).decode('utf-8', errors='ignore')
            sock.close()
            
            vuln = {
                'type': 'SSH Banner Disclosure',
                'severity': 'Low',
                'description': f'SSH banner: {banner.strip()}',
                'target': f"{target_ip}:{port}",
                'banner': banner.strip()
            }
            vulnerabilities.append(vuln)
            print(f"[!] SSH banner: {banner.strip()}")
            
            # Check for weak SSH versions
            if 'OpenSSH' in banner:
                version_match = re.search(r'OpenSSH_(\d+\.\d+)', banner)
                if version_match:
                    version = version_match.group(1)
                    if float(version) < 7.0:
                        vuln = {
                            'type': 'Outdated SSH Version',
                            'severity': 'High',
                            'description': f'Outdated OpenSSH version: {version}',
                            'target': f"{target_ip}:{port}",
                            'version': version
                        }
                        vulnerabilities.append(vuln)
                        print(f"[!] Outdated SSH version: {version}")
        
        except Exception as e:
            self.logger.error(f"Error checking SSH vulnerabilities: {e}")
        
        return vulnerabilities
    
    def check_telnet_vulnerabilities(self, target_ip, port):
        """
        Check Telnet service for vulnerabilities
        """
        vulnerabilities = []
        
        try:
            sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
            sock.settimeout(5)
            sock.connect((target_ip, port))
            
            # Read banner
            banner = sock.recv(1024).decode('utf-8', errors='ignore')
            sock.close()
            
            vuln = {
                'type': 'Telnet Service',
                'severity': 'High',
                'description': f'Telnet service detected (unencrypted): {banner.strip()}',
                'target': f"{target_ip}:{port}",
                'banner': banner.strip()
            }
            vulnerabilities.append(vuln)
            print(f"[!] Telnet service (unencrypted): {banner.strip()}")
        
        except Exception as e:
            self.logger.error(f"Error checking Telnet vulnerabilities: {e}")
        
        return vulnerabilities
    
    def scan(self, target, port=80, scan_type='web'):
        """
        Main scanning function
        """
        start_time = time.time()
        
        if scan_type == 'web':
            if not target.startswith(('http://', 'https://')):
                target = f'http://{target}'
            vulnerabilities = self.check_web_vulnerabilities(target)
        else:
            vulnerabilities = self.check_network_vulnerabilities(target, port)
        
        scan_duration = time.time() - start_time
        
        # Print summary
        print("\n" + "="*60)
        print("VULNERABILITY SCAN SUMMARY")
        print("="*60)
        print(f"Target: {target}")
        print(f"Scan Type: {scan_type}")
        print(f"Duration: {scan_duration:.2f} seconds")
        print(f"Vulnerabilities Found: {len(vulnerabilities)}")
        
        if vulnerabilities:
            print("\nVULNERABILITIES:")
            print("-" * 40)
            
            # Group by severity
            high_vulns = [v for v in vulnerabilities if v['severity'] == 'High']
            medium_vulns = [v for v in vulnerabilities if v['severity'] == 'Medium']
            low_vulns = [v for v in vulnerabilities if v['severity'] == 'Low']
            
            for severity, vulns in [('HIGH', high_vulns), ('MEDIUM', medium_vulns), ('LOW', low_vulns)]:
                if vulns:
                    print(f"\n{severity} SEVERITY:")
                    for i, vuln in enumerate(vulns, 1):
                        print(f"  {i}. {vuln['type']}")
                        print(f"     Description: {vuln['description']}")
                        if 'url' in vuln:
                            print(f"     URL: {vuln['url']}")
                        elif 'target' in vuln:
                            print(f"     Target: {vuln['target']}")
                        print()
        else:
            print("\n[+] No vulnerabilities found!")
        
        # Log results
        vuln_types = [v['type'] for v in vulnerabilities]
        log_scan_result(
            self.logger,
            'vulnerability_scan',
            target,
            vulnerabilities=vuln_types
        )
        
        return {
            'target': target,
            'scan_type': scan_type,
            'vulnerabilities': vulnerabilities,
            'scan_duration': scan_duration,
            'total_vulnerabilities': len(vulnerabilities)
        }

def main():
    """
    Command line interface for Vulnerability Scanner
    """
    parser = argparse.ArgumentParser(description='Vulnerability Scanner - Ethical Hacking Tools')
    parser.add_argument('-t', '--target', required=True, help='Target URL or IP address')
    parser.add_argument('-p', '--port', type=int, default=80, help='Target port (for network scans)')
    parser.add_argument('-s', '--scan-type', choices=['web', 'network'], default='web', 
                       help='Type of scan to perform')
    
    args = parser.parse_args()
    
    scanner = VulnerabilityScanner()
    scanner.scan(args.target, args.port, args.scan_type)

if __name__ == "__main__":
    main()
